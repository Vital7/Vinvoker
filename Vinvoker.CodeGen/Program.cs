using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using ArchiSteamFarm.Steam;

namespace Vinvoker.CodeGen {
	internal static class Program {
		private static readonly string Header = @"// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the data builder generator tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
".Replace("\r\n", "\n").Replace("\n", Environment.NewLine);

		private static async Task Main() {
			string path = Path.Join("..", "Vinvoker", "Generated");
			if (!Directory.Exists(path)) {
				Directory.CreateDirectory(path);
			}

			var types = new[] { typeof(Bot) };
			await Generate(types, path).ConfigureAwait(false);
		}

		private static async Task Generate(IEnumerable<Type> typesToGenerate, string path) {
			try {
				foreach (Type typeToGenerate in typesToGenerate) {
					StringBuilder generatedCode = new(Header);
					generatedCode.Append("namespace Vinvoker.Interfaces {\n\tpublic interface I");
					generatedCode.Append(typeToGenerate.Name + " {\n");

					PropertyInfo[] properties = typeToGenerate.GetProperties(BindingFlags.Public | BindingFlags.Instance);
					foreach (PropertyInfo property in properties) {
						generatedCode.Append("\t\tpublic " + GetFriendlyTypeName(property.PropertyType) + " " + property.Name + " {");
						if (property.GetMethod?.IsPublic == true) {
							generatedCode.Append(" get;");
						}

						if (property.SetMethod?.IsPublic == true) {
							generatedCode.Append(" set;");
						}

						generatedCode.Append(" }\n");
					}

					MethodInfo[] methods = typeToGenerate.GetMethods(BindingFlags.Public | BindingFlags.Instance)
						.Where(x => !x.IsSpecialName && (x.DeclaringType != typeof(object))).ToArray();

					foreach (MethodInfo method in methods) {
						generatedCode.Append(
							"\t\tpublic " + GetFriendlyTypeName(method.ReturnType) + " " + method.Name + "(" +
							string.Join(", ", method.GetParameters().Select(param => GetFriendlyTypeName(param.ParameterType) + " " + param.Name)) + ");\n"
						);
					}

					generatedCode.Append("\t}\n}\n\n");

					generatedCode.Append("namespace Vinvoker.Implementations {\n\tpublic class ASF");
					generatedCode.Append(typeToGenerate.Name + " : Vinvoker.Interfaces.I" + typeToGenerate.Name + " {\n");
					generatedCode.Append(
						"\t\tpublic ASF" + typeToGenerate.Name + "(" + typeToGenerate.FullName +
						" implementation) => Implementation = implementation;\n"
					);

					generatedCode.Append("\t\tprivate readonly " + typeToGenerate.FullName + " Implementation;\n");

					foreach (PropertyInfo property in properties) {
						generatedCode.Append("\t\tpublic " + GetFriendlyTypeName(property.PropertyType) + " " + property.Name + " ");

						if (property.GetMethod?.IsPublic == true) {
							if (property.SetMethod?.IsPublic == true) {
								generatedCode.Append("{\n\t\t\tget => Implementation." + property.Name + ";\n");
								generatedCode.Append("\n\t\t\tset => Implementation." + property.Name + " = value;\n\t\t}\n");
							} else {
								generatedCode.Append("=> Implementation." + property.Name + ";\n");
							}
						}
					}

					foreach (MethodInfo method in methods) {
						generatedCode.Append(
							"\t\tpublic " + GetFriendlyTypeName(method.ReturnType) + " " + method.Name + "(" +
							string.Join(", ", method.GetParameters().Select(param => GetFriendlyTypeName(param.ParameterType) + " " + param.Name)) +
							") => Implementation." + method.Name + "(" + string.Join(", ", method.GetParameters().Select(param => param.Name)) + ");\n"
						);
					}

					generatedCode.Append("\t}\n}\n");
					await File.WriteAllTextAsync(Path.Join(path, $"{typeToGenerate.Name}_generated.cs"), generatedCode.ToString());
				}
			} catch (Exception e) {
				Console.WriteLine(e);
			}
		}

		public static string GetFriendlyTypeName(Type type) {
			if (type.IsGenericParameter) {
				return type.Name;
			}

			if (!type.IsGenericType) {
				return type.FullName?.Replace('+', '.');
			}

			StringBuilder builder = new();
			string name = type.Name;
			int index = name.IndexOf("`", StringComparison.Ordinal);
			builder.Append(type.Namespace);
			builder.Append('.');
			builder.Append(name[..index]);
			builder.Append('<');
			bool first = true;
			foreach (Type arg in type.GetGenericArguments()) {
				if (!first) {
					builder.Append(',');
				}
				builder.Append(GetFriendlyTypeName(arg));
				first = false;
			}
			builder.Append('>');

			return builder.ToString();
		}
	}
}
